"""
This program allows reading the voltage across the photodiodes using an NI-PCI 6221 card.
Doc NI-PCI 6221
https://www.ni.com/docs/fr-FR/bundle/pci-pxi-usb-6221-specs/page/specs.html

"""
import time
import numpy as np
import nidaqmx
from nidaqmx.constants import AcquisitionType, TerminalConfiguration

# Function acquisition_tension

def get_solution_cuvette():
    """
    Demande à l'utilisateur dans quelle cuve il a mis la référence
    """
    solution = input("Dans quelle cuve numéro est la solution blanche : cuve 1 ou cuve 2 : ")
    while solution not in ['cuve 1', 'cuve 2']:
        solution = input("Veuillez choisir cuve 1 ou cuve 2 : ")
    print("La solution de blanc est dans la", solution)
    return solution


def task_ni_pci_baseline(samples_per_channel, sample_rate, square_wave_frequency, channels):
    """
    Récupère seulement la tensions aux bornes des photodiodes pour effectuer la baseline de l'expérience
    Args:
        samples_per_channel (int): Nombre d'échantillons par canal.
        sample_rate (float): Taux d'échantillonnage en Hz.
        square_wave_frequency (float): Fréquence du signal carré.
        channels (str): Configuration des canaux.
    Returns:
        mean (float): Moyenne des tensions minimales.
    """

    min_voltages= []
    with nidaqmx.Task() as task_voltage:
        task_voltage.ai_channels.add_ai_voltage_chan(channels, terminal_config=TerminalConfiguration.DIFF)
        task_voltage.timing.cfg_samp_clk_timing(sample_rate, samps_per_chan=samples_per_channel, sample_mode=AcquisitionType.FINITE)
        frequency = int(square_wave_frequency[0])
        for _ in range(frequency):
            # Acquisition des données
            data = task_voltage.read(number_of_samples_per_channel=samples_per_channel)
            # Conversion des données en un tableau numpy pour faciliter les calculs
            np_data = np.array(data)
            # Trouver et stocker le minimum
            min_voltage = np.min(np_data)
            min_voltages.append(min_voltage)
        task_voltage.stop()
        mean = np.mean(min_voltages)
    return mean


def task_ni_pci_scanning(samples_per_channel, sample_rate,
                square_wave_frequency, duty_cycle, channels):
    """
    Fonction qui pilote la lampe à arc aux xénon en générant un signal créneau
    et qui récupère les tensions aux bornes des photodiodes
    Args:
        samples_per_channel (int): Nombre d'échantillons par canal.
        sample_rate (float): Taux d'échantillonnage en Hz.
        square_wave_frequency (float): Fréquence du signal carré.
        duty_cycle (float): Rapport cyclique du signal carré.
        channels (str): Configuration des canaux.
    Returns:
        mean (float): Moyenne des tensions minimales.
    
    """
    min_voltages=[]
    with nidaqmx.Task() as task_impulsion, nidaqmx.Task() as task_voltage:
        task_impulsion.co_channels.add_co_pulse_chan_freq('/Dev1/ctr0',
            freq=square_wave_frequency[0], duty_cycle=duty_cycle[0], initial_delay=0.0)
        task_impulsion.timing.cfg_implicit_timing(sample_mode=AcquisitionType.CONTINUOUS)

        print(f"Génération du train d'impulsions avec une fréquence de {square_wave_frequency[0]} Hz et un rapport cyclique de {duty_cycle[0]}")
        task_impulsion.start()

        task_voltage.ai_channels.add_ai_voltage_chan(channels, terminal_config=TerminalConfiguration.DIFF)
        task_voltage.timing.cfg_samp_clk_timing(sample_rate, samps_per_chan=samples_per_channel, sample_mode=AcquisitionType.FINITE)
        frequency = int(square_wave_frequency[0])
        for _ in range(frequency):
            # Acquisition des données
            data = task_voltage.read(number_of_samples_per_channel=samples_per_channel)
            # Conversion des données en un tableau numpy pour faciliter les calculs
            np_data = np.array(data)
            # Trouver et stocker le minimum
            min_voltage = np.min(np_data)
            min_voltages.append(min_voltage)
        task_impulsion.stop()
        task_voltage.stop()
        mean = np.mean(min_voltages)
    return mean



def task_ni_pci_chemical_kinetics(samples_per_channel, sample_rate,
                                  square_wave_frequency, duty_cycle, channels, time_acquisition):
    """
    Fonction qui pilote la lampe à arc aux xénon en générant un signal créneau
    et qui récupère les tensions aux bornes des photodiodes
    Args:
        samples_per_channel (int): Nombre d'échantillons par canal.
        sample_rate (float): Taux d'échantillonnage en Hz.
        square_wave_frequency (float): Fréquence du signal carré.
        duty_cycle (float): Rapport cyclique du signal carré.
        channels (str): Configuration des canaux.
        time_acquisition (float): Durée de l'acquisition en secondes.
    Returns:
        mean (float): Moyenne des tensions minimales.
    """
    min_voltages = []

    with nidaqmx.Task() as task_impulsion, nidaqmx.Task() as task_voltage:
        task_impulsion.co_channels.add_co_pulse_chan_freq('/Dev1/ctr0',
                                                          freq=square_wave_frequency[0], duty_cycle=duty_cycle[0],
                                                          initial_delay=0.0)
        task_impulsion.timing.cfg_implicit_timing(sample_mode=AcquisitionType.CONTINUOUS)

        print(f"Génération du train d'impulsions avec une fréquence de {square_wave_frequency[0]} Hz et un rapport cyclique de {duty_cycle[0]}")
        task_impulsion.start()

        task_voltage.ai_channels.add_ai_voltage_chan(channels, terminal_config=TerminalConfiguration.DIFF)
        task_voltage.timing.cfg_samp_clk_timing(sample_rate, samps_per_chan=samples_per_channel,
                                                sample_mode=AcquisitionType.FINITE)

        start_time = time.time()  # Début du comptage du temps
        while time.time() - start_time < time_acquisition:  # Boucle pendant la durée spécifiée
            # Acquisition des données
            data = task_voltage.read(number_of_samples_per_channel=samples_per_channel)
            # Conversion des données en un tableau numpy pour faciliter les calculs
            np_data = np.array(data)
            # Trouver et stocker le minimum
            min_voltage = np.min(np_data)
            min_voltages.append(min_voltage)

        task_impulsion.stop()
        task_voltage.stop()
        mean = np.mean(min_voltages)

    return mean  # Retourne la moyenne des tensions minimales


def voltage_acquisition_baseline(samples_per_channel, sample_rate,
                        square_wave_frequency, channels, channel):
    """
    Renvois la valeur de la tension entre du channel 'ai0' ou 'ai1'
    (il faut que je développe ce commentaire avec la doc NI-PCI 6221)
    Args:
        samples_per_channel (int): Nombre d'échantillons par canal.
        sample_rate (float): Taux d'échantillonnage en Hz.
        square_wave_frequency (float): Fréquence du signal carré.
        channels (list): Liste de configurations des canaux.
        channel (str): Nom du canal à acquérir ('ai0' ou 'ai1').
    Returns:
        mean (float): Moyenne des tensions minimales.
    """
    if channel == 'ai0': # Acquisition sur le 1er capteur
        mean = task_ni_pci_baseline(samples_per_channel, sample_rate, square_wave_frequency, channels[0])
        return mean

    elif channel == 'ai1': # Acquisition sur le 2ème capteur
        mean = task_ni_pci_baseline(samples_per_channel, sample_rate, square_wave_frequency, channels[1])
        return mean
    
def voltage_acquisition_scanning(samples_per_channel, sample_rate,
                        square_wave_frequency, duty_cycle, channels, channel):
    """
    Renvois la valeur de la tension entre du channel 'ai0' ou 'ai1'
    (il faut que je développe ce commentaire avec la doc NI-PCI 6221)
    Args:
        samples_per_channel (int): Nombre d'échantillons par canal.
        sample_rate (float): Taux d'échantillonnage en Hz.
        square_wave_frequency (float): Fréquence du signal carré.
        duty_cycle (float): Rapport cyclique du signal carré.
        channels (list): Liste de configurations des canaux.
        channel (str): Nom du canal à acquérir ('ai0' ou 'ai1').
    Returns:
        mean (float): Moyenne des tensions minimales.
    """
    if channel == 'ai0': # Acquisition sur le 1er capteur
        mean = task_ni_pci_scanning(samples_per_channel, sample_rate, square_wave_frequency, duty_cycle, channels[0])
        return mean

    elif channel == 'ai1': # Acquisition sur le 2ème capteur
        mean = task_ni_pci_scanning(samples_per_channel, sample_rate, square_wave_frequency, duty_cycle, channels[1])
        return mean
# End-of-file (EOF)